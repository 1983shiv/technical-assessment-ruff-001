Here's a **Frontend Technical Assessment (TypeScript, Easy Difficulty)** that covers:

* A **realistic UI scenario** (a controlled component: feedback form with validation).
* **Partially completed source code** with **TODOs** for core logic.
* **Edge cases** clearly implied (e.g., empty fields, invalid email).
* A **unit test file** with both written and missing test cases.

---

## ðŸ“˜ Scenario: **Feedback Form Component**

Build a simple feedback form that accepts:

* **User Name**
* **Email**
* **Feedback Message**

The form:

* Should show validation messages on blur.
* Submit button must be disabled if the form is invalid.
* On successful submission, shows a thank you message.

---

## ðŸ“ `FeedbackForm.tsx`

```tsx
import { useState } from 'react';

type FormData = {
  name: string;
  email: string;
  message: string;
};

type FormErrors = {
  name?: string;
  email?: string;
  message?: string;
};

const defaultData: FormData = {
  name: '',
  email: '',
  message: '',
};

export const FeedbackForm = () => {
  const [data, setData] = useState<FormData>(defaultData);
  const [errors, setErrors] = useState<FormErrors>({});
  const [submitted, setSubmitted] = useState(false);

  const validate = (field: keyof FormData, value: string): string | undefined => {
    switch (field) {
      case 'name':
        // TODO: Name should not be empty
        break;
      case 'email':
        // TODO: Validate email format
        break;
      case 'message':
        // TODO: Require minimum 10 characters
        break;
    }
    return undefined;
  };

  const handleChange = (field: keyof FormData) => (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const value = e.target.value;
    setData((prev) => ({ ...prev, [field]: value }));
    setErrors((prev) => ({ ...prev, [field]: validate(field, value) }));
  };

  const isFormValid = (): boolean => {
    // TODO: Implement logic to check if all fields are valid (errors object is empty)
    return false;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const newErrors: FormErrors = {};

    (Object.keys(data) as (keyof FormData)[]).forEach((key) => {
      const error = validate(key, data[key]);
      if (error) newErrors[key] = error;
    });

    setErrors(newErrors);
    if (Object.keys(newErrors).length === 0) {
      // Submit logic here
      setSubmitted(true);
    }
  };

  if (submitted) {
    return <p data-testid="thank-you">Thank you for your feedback!</p>;
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Your Name"
        value={data.name}
        onChange={handleChange('name')}
        onBlur={(e) => setErrors((prev) => ({ ...prev, name: validate('name', e.target.value) }))}
        data-testid="name-input"
      />
      {errors.name && <p className="error">{errors.name}</p>}

      <input
        type="email"
        placeholder="Your Email"
        value={data.email}
        onChange={handleChange('email')}
        onBlur={(e) => setErrors((prev) => ({ ...prev, email: validate('email', e.target.value) }))}
        data-testid="email-input"
      />
      {errors.email && <p className="error">{errors.email}</p>}

      <textarea
        placeholder="Your Message"
        value={data.message}
        onChange={handleChange('message')}
        onBlur={(e) => setErrors((prev) => ({ ...prev, message: validate('message', e.target.value) }))}
        data-testid="message-input"
      />
      {errors.message && <p className="error">{errors.message}</p>}

      <button type="submit" disabled={!isFormValid()} data-testid="submit-btn">
        Submit
      </button>
    </form>
  );
};
```

---

## âœ… Edge Cases to Consider

* Empty name, email, or message.
* Invalid email format (`test@`, `hello.com`).
* Message with fewer than 10 characters.
* Button should stay disabled until valid.
* Show validation only after blur or submit.

---

## ðŸ§ª `FeedbackForm.test.tsx`

```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { FeedbackForm } from './FeedbackForm';

describe('FeedbackForm', () => {
  it('renders all input fields and submit button', () => {
    render(<FeedbackForm />);
    expect(screen.getByTestId('name-input')).toBeInTheDocument();
    expect(screen.getByTestId('email-input')).toBeInTheDocument();
    expect(screen.getByTestId('message-input')).toBeInTheDocument();
    expect(screen.getByTestId('submit-btn')).toBeDisabled();
  });

  it('shows error when name is empty after blur', () => {
    render(<FeedbackForm />);
    const nameInput = screen.getByTestId('name-input');
    fireEvent.blur(nameInput);
    // TODO: Expect an error message for empty name
  });

  it('shows error for invalid email format', () => {
    render(<FeedbackForm />);
    const emailInput = screen.getByTestId('email-input');
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } });
    fireEvent.blur(emailInput);
    // TODO: Expect error message for invalid email
  });

  it('enables submit button only when form is valid', () => {
    render(<FeedbackForm />);
    fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John Doe' } });
    fireEvent.change(screen.getByTestId('email-input'), { target: { value: 'john@example.com' } });
    fireEvent.change(screen.getByTestId('message-input'), { target: { value: 'A valid message!' } });

    // TODO: Expect button to be enabled
  });

  it('shows thank you message on successful submission', () => {
    render(<FeedbackForm />);
    fireEvent.change(screen.getByTestId('name-input'), { target: { value: 'John' } });
    fireEvent.change(screen.getByTestId('email-input'), { target: { value: 'john@example.com' } });
    fireEvent.change(screen.getByTestId('message-input'), { target: { value: 'This is a long enough message.' } });

    const button = screen.getByTestId('submit-btn');
    fireEvent.click(button);

    // TODO: Expect thank you message to be shown
  });
});
```

---

Let me know if you'd like:

* A version using `React Hook Form`
* Styled UI with Tailwind or MUI
* Added backend simulation using `msw`
* A medium or hard version with nested form or autosave behavior
